<!DOCTYPE html>

<html>
    <head>
        <script>
		    
			/*
			*HW 2 Linear Regression and PLA in HTML and Javascript by __________ as of 10/23/13
			*After submitting my answers to the homework, I spent some additional time debugging and organizing the code.
			*/
			
			//meta
            var numExperiments;//how many experiments we should run before we stop
			var experimentFunction;//We have several types of experiments we can run. start() makes this point to the function for the experiment the user chose. 
            var millisecondsPerStep;////interval at which we should call the step function, which does one iteration of PLA or one linear regression experiment
            var stepInterval;//interval variable that refers to the timer that periodically fires events that trigger the step function
			var reults;//array storing ExperimentResult objects for completed experiments
			
			//display
            var lCanvas;
            var lContext;
            var targetLineColor = "#00FFFF";
            var hypothesisLineColor = "#FFFF00";
			var plaSelectedPointColor = "#FF00FF";//When running the PLA, circle the point the PLA has selected in black.
            var pointPlotRadius = 5;
            var experimentCountSpan;
			
			//constants describing the basic setup
			//point: a matrix of the form [1, x1, x2] where x1 is the x coordinate and x2 is the y coordinate and both are on the interval [-1, 1].
            var pointDefaultNumDims = 2;
            var pointMinCoord = -1;
            var pointMaxCoord = 1;
            var linearGradientDefaultNumPoints = 3;//When randomly generating a plane, use 3 points to define it.
			//The experiments deal with functions that map points in the plane to either -1 or +1.
            var minValue = -1;
            var maxValue = 1;
			var zeroed2DWeightMatrix = [0, 0, 0];//Pass this in to LinearGradient to tell it to start with zeroed weightMatrix.
			var targetNonLinearWeightArray = [-0.6, 0, 0, 0, 1, 1];//sign(-0.6+0*x1+0*x2+0*x1*x2+1*x1*x1+1*x2*x2) Pass this in to LinearGradient to tell it to use these values as weights.
			
			//The PLA takes multiple steps, so we run it over multiple stepInterval timer events.
			//Use these variables to store the state from one step to the next.
			
			//used with all
			var inPoints;//Ninx(d+1) Matrix, randomly generated training data set with rows of the form [1, x1, x2]
			var outPoints;//Noutx(d+1) Matrix randomly generated testing data set with rows of the form [1, x1, x2]
			var targetGradient;//(d+1)x1 Matrix, the LinearGradient object we use to classify the points in the target function
			var targetInValues;//Ninx1 Matrix, the classification values generated by sign(inPoints*targetGradient.weights), used as training data
			var targetOutValues;//Noutx1 Matrix, the classification values generated by sign(outPoints*targetGradient.weights), used as testing data
			var hypothesisGradient;//(d+1)x1 Matrix, the LinearGradient object we use for the linear regression to find the initial weights
			var hypothesisInValues;//Ninx1 Matrix, the classification values generated by sign(inPoints*hypothesisGradient.weights)
			var hypothesisOutValues;//Noutx1 Matrix, the classification values generated by sign(outPoints*targetGradient.weights)
			//We use the diffHalf matrices both for selecting misclassified points in the PLA and calculating in-sample and out-of-sample error values.
			var diffHalfIn;//Ninx1 Matrix, 0.5*(hypothesisInValues - targetInValues)
			var diffHalfOut;//Noutx1 Matrix, 0.5*(hypothesisOutValues - targetOutValues)
			
			//used with PLA
			var runningPLA;//bool, a PLA is currently in progress
            var plaStepCount;//int, the number of PLA steps we have run so far
			var plaSelectedPoint;//1x(d+1) Matrix, the misclassified point Matrix object the perceptron selected this iteration
			var plaSelectedTargetValue;//1x1 Matrix, singleton matrix containing the target value of plaSelectedPoint
			
			//used with non-linear target and/or hypothesis
			var augmentedInPoints;//same as inPoints, but each row has the form [1, x1, x2, x1*x2, x1*x1, x2*x2]
			var augmentedOutPoints;//same as inPoints, but each row has the form [1, x1, x2, x1*x2, x1*x1, x2*x2]
			
			//a general-purpose matrix class
            function Matrix() {
                var fillerValue = 0;//If we expand the array and need a default value.
                var elements = new Array();//The elements of the matrix arranged [m00, m01, m02, … m0c, m10, m11, m12, … m1c, … mr0, mr1, mr2, … mrc] where r = numRows-1, c = numColumns-1.
                var numRows = 0;
                var numColumns = 0;
                
                this.pushRow = function(newRow) {
                    if(numColumns < newRow.length) {
                        var newElements = new Array();
                        var rowIndex;
                        var columnIndex;
                        var newNumColumns = newRow.length;
                        for(rowIndex=0; rowIndex<numRows; rowIndex++) {
                            for(columnIndex=0; columnIndex < newNumColumns; columnIndex++) {
                                if(columnIndex < numColumns) {
                                    newElements[rowIndex*newNumColumns + columnIndex] = elements[rowIndex*numColumns + columnIndex];
                                }
                                else {
                                    newElements[rowIndex*newNumColumns + columnIndex] = fillerValue;
                                }
                            }
                        }
                        elements = newElements.concat(newRow);
                        numColumns = newNumColumns;
                    }
                    else if(numColumns == newRow.length) {
                        elements = elements.concat(newRow);
                    }
                    else {//numColumns > newRow.length
                        var index;
                        var filler = new Array();
                        for(index=newRow.length; index<numColumns; index++) {
                            filler.push(fillerValue);
                        }
                        elements = elements.concat( newRow.concat(filler) );
                    }
                    numRows++;
                };
                
                this.getElement = function(rowIndex, columnIndex) {
                    return elements[rowIndex*numColumns + columnIndex];
                };
                
                this.getNumRows = function() {
                    return numRows;
                };
                
                this.getNumColumns = function() {
                    return numColumns;
                };
                
                this.getRow = function(rowIndex) {
                    return elements.slice(rowIndex*numColumns, (rowIndex+1)*numColumns);
                };
                
                this.getColumn = function(columnIndex) {
                    var column = new Array();
                    var rowIndex;
                    for(rowIndex=0; rowIndex<numRows; rowIndex++) {
                        column.push( this.getElement(rowIndex, columnIndex) );
                    }
                    return column;
                };
                
                this.getBlock = function(firstRow, firstColumn, blockNumRows, blockNumColumns) {
                    var stopRow = firstRow+blockNumRows;
                    var stopColumn = firstColumn+blockNumColumns;
                    var rowIndex;
                    var blockRow;
                    var block = new Matrix();
                    for(rowIndex = firstRow; rowIndex < stopRow; rowIndex++) {
                        blockRow = elements.slice(rowIndex*numColumns + firstColumn, rowIndex*numColumns + stopColumn);
                        block.pushRow(blockRow);
                    }
                    return block;
                };
                
                //thisMatrix otherMatrix
                this.getMergedLeftRight = function(other) {
                    if(this.getNumRows() != other.getNumRows()) {
                        console.log("Warning: trying to merge rows of "+this.getNumRows()+"x"+this.getNumColumns()+" matrix and "+other.getNumRows()+"x"+other.getNumColumns()+" matrix");
                    }
                    var mergeRows = Math.min(this.getNumRows(), other.getNumRows());
                    var rowIndex;
                    var columnIndex;
                    var sourceRow1;
                    var sourceRow2;
                    var merge = new Matrix();
                    for(rowIndex = 0; rowIndex < mergeRows; rowIndex++) {
                        sourceRow1 = this.getRow(rowIndex);
                        sourceRow2 = other.getRow(rowIndex);
                        merge.pushRow(sourceRow1.concat(sourceRow2));
                    }
                    //console.log("merged "+this.toString()+" and "+other.toString()+" horizontally to get "+merge.toString());
                    return merge;
                };
                
                //thisMatrix
                //otherMatrix
                this.getMergedTopBottom = function(other) {
                    if(this.getNumColumns() != other.getNumColumns()) {
                        console.log("Warning: trying to merge columns of "+this.getNumRows()+"x"+this.getNumColumns()+" matrix and "+other.getNumRows()+"x"+other.getNumColumns()+" matrix");
                    }
                    var rowIndex;
                    var merge = new Matrix();
                    for(rowIndex = 0; rowIndex < this.getNumRows(); rowIndex++) {
                        merge.pushRow(this.getRow(rowIndex));
                    }
                    for(rowIndex = 0; rowIndex < other.getNumRows(); rowIndex++) {
                        merge.pushRow(other.getRow(rowIndex));
                    }
                    //console.log("merged "+this.toString()+" and "+other.toString()+" vertically to get "+merge.toString());
                    return merge;
                };
                
                //thisMatrix + otherMatrix
                this.getSum = function(other) {
                    if( (this.getNumRows() != other.getNumRows()) || (this.getNumColumns() != other.getNumColumns()) ) {
                        console.log("Warning: trying to add "+this.getNumRows()+"x"+this.getNumColumns()+" matrix to "+other.getNumRows()+"x"+other.getNumColumns()+" matrix");
                    }
                    var sumRows = Math.min(this.getNumRows(), other.getNumRows());
                    var sumColumns = Math.min(this.getNumColumns(), other.getNumColumns());
                    var rowIndex;
                    var columnIndex;
                    var sourceRow1;
                    var sourceRow2;
                    var sumRow;
                    var sum = new Matrix();
                    for(rowIndex = 0; rowIndex < sumRows; rowIndex++) {
                        sourceRow1 = this.getRow(rowIndex);
                        sourceRow2 = other.getRow(rowIndex);
                        sumRow = new Array();
                        for(columnIndex = 0; columnIndex < sumColumns; columnIndex++) {
                            sumRow[columnIndex] = sourceRow1[columnIndex] + sourceRow2[columnIndex];
                        }
                        sum.pushRow(sumRow);
                    }
                    return sum;
                };
                
                this.getScaled = function(scalar) {
                    var rowIndex;
                    var columnIndex;
                    var sourceRow;
                    var scaledRow;
                    var scaled = new Matrix();
                    for(rowIndex = 0; rowIndex < numRows; rowIndex++) {
                        sourceRow = this.getRow(rowIndex);
                        scaledRow = new Array();
                        for(columnIndex = 0; columnIndex < numColumns; columnIndex++) {
                            scaledRow[columnIndex] = scalar*sourceRow[columnIndex];
                        }
                        scaled.pushRow(scaledRow);
                    }
                    return scaled;
                    
                };
                
                //thisMatrix x otherMatrix 
                this.getProduct = function(other) {
                    if(this.getNumColumns() != other.getNumRows()) {
                        console.log("Warning: trying to multiply a matrix with "+this.getNumColumns()+" columns by one with "+other.getNumRows()+" rows");
                        //console.log(this.toString()+"x"+other.toString());
                    }
                    var productRows = this.getNumRows();
                    var productColumns = other.getNumColumns();
                    var termsPerElement = Math.min(this.getNumColumns(), other.getNumRows());
                    
                    var product = new Matrix();
                    
                    var rowIndex;
                    var columnIndex;
                    var termIndex;
                    var productRow;
                    var element;
                    var factorRow;
                    var factorColumn;
                    for(rowIndex = 0; rowIndex < productRows; rowIndex++) {
                        factorRow = this.getRow(rowIndex);
                        productRow = new Array();
                        for(columnIndex = 0; columnIndex < productColumns; columnIndex++) {
                            factorColumn = other.getColumn(columnIndex);
                            element = 0;
                            for(termIndex = 0; termIndex < termsPerElement; termIndex++) {
                                element += factorRow[termIndex]*factorColumn[termIndex];
                            }
                            productRow[columnIndex] = element;
                        }
                        product.pushRow(productRow);
                    }
                    
                    return product;
                }; 
                
                this.getTranspose = function() {
                    var transpose = new Matrix();
                    var index;
                    for(index=0; index<numColumns; index++) {
                        transpose.pushRow(this.getColumn(index));
                    }
                    return transpose;
                };   
                
                //computes the inverse using block decomposition
                this.getInverse = function() {
                    if(numRows != numColumns) {
                        console.log("Warning: computing inverse of non-square matrix with "+numRows+" rows and "+numColumns+" columns");
                    }
                    var sideLength = Math.min(numRows, numColumns);
                    var inverse;
                    if(sideLength == 0) {
                        console.log("Warning: computing inverse of empty matrix, returning an empty matrix");
                    }
                    else if(sideLength == 1) {
                        var multiplicativeInverse;
                        inverse = new Matrix();
                        if(elements[0] == 0) {
                            console.log("Warning: base case of matrix.getInverse encountered [ 0 ] matrix.");
                            multiplicativeInverse = 0;
                        }
                        else {
                            multiplicativeInverse = 1.0/elements[0];
                            //console.log("getInverse: base case inverse("+elements[0]+")="+multiplicativeInverse);
                        }
                        inverse.pushRow([ multiplicativeInverse ]);
                    }
                    else {
                        var sideLengthA = Math.round(sideLength/2);
                        var sideLengthD = sideLength - sideLengthA;
                        var A = this.getBlock(0, 0, sideLengthA, sideLengthA);//first sideLengthA columns of first sideLengthA rows
                        var B = this.getBlock(0, sideLengthA, sideLengthA, sideLengthD);//remaining sideLengthD columns of first sideLengthA rows
                        var C = this.getBlock(sideLengthA, 0, sideLengthD, sideLengthA);//first sideLengthA columns of remaining sideLengthD rows
                        var D = this.getBlock(sideLengthA, sideLengthA, sideLengthD, sideLengthD);//remaining sideLengthD rows of remaining sideLengthD columns
                        //console.log("breaking up matrix into blocks:");
                        //console.log("A="+A.toString());
                        //console.log("B="+B.toString());
                        //console.log("C="+C.toString());
                        //console.log("D="+D.toString());
                        var inverseA = A.getInverse();
                        //console.log("inverse(A)="+inverseA.toString());
                        var inverseAB = inverseA.getProduct(B);//(inverseA)B
                        //console.log("inverse(A)*B="+inverseAB.toString());
                        var CinverseA = C.getProduct( inverseA );//C(inverseA)
                        //console.log("C*inverse(A)="+CinverseA.toString());
                        var CinverseAB = C.getProduct( inverseAB );//C(inverseA)B
                        //console.log("C*inverse(A)*B="+CinverseAB.toString());
                        var schurComplement = D.getSum( CinverseAB.getScaled(-1) );//D - C(inverseA)B
                        //console.log("D-C*inverse(A)*B="+schurComplement.toString());
                        var inverseSchurComplement = schurComplement.getInverse();//inverse(D - C(inverseA)B)
                        //console.log("inverse(D-C*inverse(A)*B)="+inverseSchurComplement.toString());
                        var inverseABinverseSchurComplement = inverseAB.getProduct(inverseSchurComplement);//(inverseA)Binverse(D - C(inverseA)B)
                        //console.log("inverse(A)*B*inverse(D-C*inverse(A)*B)="+inverseABinverseSchurComplement.toString());
                        var inverseSchurComplementCinverseA = inverseSchurComplement.getProduct(CinverseA);//inverse(D - C(inverseA)B)C(inverseA)
                        //console.log("inverse(D-C*inverse(A)*B)*C*inverse(A)="+inverseSchurComplementCinverseA.toString());
                        var topLeft = inverseA.getSum( inverseABinverseSchurComplement.getProduct(CinverseA) );//A+(inverseA)Binverse(D - C(inverseA)B)C(inverseA)
                        var topRight = inverseABinverseSchurComplement.getScaled(-1);//-(inverseA)Binverse(D - C(inverseA)B)
                        var bottomLeft = inverseSchurComplementCinverseA.getScaled(-1);//-inverse(D - C(inverseA)B)C(inverseA)
                        var bottomRight = inverseSchurComplement;//inverse(D - C(inverseA)B)
                        //console.log("merging blocks of inverse:");
                        //console.log("topLeft=A+inverse(D-C*inverse(A)*B)*C*inverse(A)="+topLeft.toString());
                        //console.log("topRight=-inverse(A)*B*inverse(D-C*inverse(A)*B)*C*inverse(A)="+topRight.toString());
                        //console.log("bottomLeft=-inverse(D-C*inverse(A)*B)*C*inverse(A)="+bottomLeft.toString());
                        //console.log("bottomRight=inverse(D-C*inverse(A)*B)="+bottomRight.toString());
                        var top = topLeft.getMergedLeftRight(topRight);
                        var bottom = bottomLeft.getMergedLeftRight(bottomRight);
                        inverse = top.getMergedTopBottom(bottom);
                    }
                    return inverse;
                };
                
                this.getPseudoInverse = function() {
                    //console.log("X="+this.toString())
                    var transpose = this.getTranspose();//transpose(X)
                    //console.log("transpose(X)="+transpose.toString());
                    var square = transpose.getProduct(this);//transpose(X)*X
                    //console.log("transpose(X)*X="+square.toString());
                    var inverseSquare = square.getInverse();//inverse(transpose(X)*X)
                    //console.log("inverse(transpose(X)*X)="+inverseSquare.toString());
                    var pseudoInverse = inverseSquare.getProduct(transpose);//inverse(transpose(X)*X)*transpose(X)
                    //console.log("inverse( transpose(X)*X )*transpose(X)="+pseudoInverse.toString());
                    return pseudoInverse;
                };
                
                this.getElementWiseTransform = function(elementWiseFunction) {
                    var rowIndex;
                    var columnIndex;
                    var sourceRow;
                    var transformedRow;
                    var transform = new Matrix();
                    for(rowIndex = 0; rowIndex < numRows; rowIndex++) {
                        sourceRow = this.getRow(rowIndex);
                        transformedRow = new Array();
                        for(columnIndex = 0; columnIndex < numColumns; columnIndex++) {
                            transformedRow.push( elementWiseFunction(sourceRow[columnIndex]) );
                        }
                        transform.pushRow(transformedRow);
                    }
                    return transform;
                };
                
                this.getRowWiseTransform = function(rowWiseFunction) {
                    var rowIndex;
                    var transform = new Matrix();
                    for(rowIndex = 0; rowIndex < numRows; rowIndex++) {
                        transform.pushRow(  rowWiseFunction( this.getRow(rowIndex) )  );
                    }
                    return transform;
                };
                
                this.fillWithValue = function(newNumRows, newNumColumns, value) {
                    numRows = newNumRows;
                    numColumns = newNumColumns;
                    elements = new Array();
                    var numElements = numRows*numColumns;
                    var index;
                    for(index=0; index < numElements; index++) {
                        elements.push(value);
                    }
                };
                
                this.toString = function() {
                    var rowIndex;
                    var columnIndex;
                    var stringRep = "[ ";
                    for(rowIndex = 0; rowIndex < numRows; rowIndex++) {
                        stringRep = stringRep + "[";
                        for(columnIndex = 0; columnIndex < numColumns; columnIndex++) {
                            stringRep = stringRep+elements[rowIndex*numColumns + columnIndex];
                            if(columnIndex != numColumns-1) {
                                stringRep = stringRep+", ";
                            }
                        }
                        stringRep = stringRep + "]";
                        if(rowIndex == numRows-1) {
                            stringRep = stringRep+" ";
                        }
                        else {
                            stringRep = stringRep+", ";
                        }
                    }
                    return stringRep+"]";
                };
                
            }//end of Matrix() constructor
            
            function randomPointMatrix(numPoints) {
                var points = new Matrix();
                var rowIndex;
                var columnIndex;
                var pointRow;
                for(rowIndex = 0; rowIndex < numPoints; rowIndex++) {
                    pointRow = new Array();
                    pointRow[0] = 1;
                    for(columnIndex = 1; columnIndex <= pointDefaultNumDims; columnIndex++) {
                        pointRow[columnIndex] = pointMinCoord + (pointMaxCoord - pointMinCoord)*Math.random();
                    }
                    points.pushRow(pointRow);
                }
                //console.log("generated random point matrix: "+points.toString());
                return points;
            }
            
			//takes in Array [1, x1, x2] and outputs Array [1, x1, x2, x1*x2, x1*x1, x2*x2]
            function pointAugmentation(pointArray) {
                return pointArray.concat([ pointArray[1]*pointArray[2], pointArray[1]*pointArray[1], pointArray[2]*pointArray[2] ]);
            }
            
			//Call this to generate the in-sample and out-of-sample data sets.
			function generatePoints(augment) {
                var numInPoints = document.getElementById("numInPointsInput").value;
                var numOutPoints = document.getElementById("numOutPointsInput").value;
                inPoints = randomPointMatrix(numInPoints);
                //console.log( "generated in-sample points "+inPoints.toString() );
                outPoints = randomPointMatrix(numOutPoints);
                //console.log( "generated out-of-sample points "+outPoints.toString() );
				if(augment) {
				    augmentedInPoints = inPoints.getRowWiseTransform(pointAugmentation);
                    augmentedOutPoints = outPoints.getRowWiseTransform(pointAugmentation);
				}
				else {
				    //Null them so that we do not accidentally use augmented points that do not match the regular points.
				    augmentedInPoints = null;
				    augmentedOutPoints = null;
				}
			}
            
            function signFunction(value) {
                if(value) {
                    return value/Math.abs(value);
                }
                else {
                    return 0;
                }
            }
            
            //Pass in an array of N point matrices and an array of N scalar values where N is at least 2. See getPointMatrix for details of point matrices.
            //regressionPointMatrix: Nx(d+1) matrix of N d-dimensional points
            //regressionValueMatrix: Nx1 matrix of N scalar values
			//Alternatively, pass in a (d+1)x1 array of numbers to use its elements as the weights.
			//Pass in no arguments to generate a random (d+1)x1 matrix of weights.
            function LinearGradient(regressionPointMatrix, regressionValueMatrix) {
                
				var weightMatrix;
				
				if(regressionPointMatrix && (typeof regressionPointMatrix === "object") && (regressionPointMatrix instanceof Array) ) {
				    weightMatrix = new Matrix();
				    weightMatrix.pushRow( regressionPointMatrix );//add array to make 1x(d+1)
					weightMatrix = weightMatrix.getTranspose();//1x(d+1)->(d+1)x1
				}
				else {
				    
                    //If the caller did not pass in any arguments, pick random points.
                    if( typeof regressionPointMatrix === "undefined" ) {
                        regressionPointMatrix = randomPointMatrix(linearGradientDefaultNumPoints);
                    }
                    
                    //If the caller did not pass in two arguments, pick random values.
                    if( typeof regressionValueMatrix === "undefined" ) {
                        var regressionValueMatrix = new Matrix();
					    var index;
                        for(index = 0; index < regressionPointMatrix.getNumRows(); index++) {
                            regressionValueMatrix.pushRow( [ minValue + (maxValue - minValue)*Math.random() ] );//singleton array of a random value
                        }//results in an Nx1 column matrix
                    }
					
					//console.log("performing linear regression with points "+regressionPointMatrix.toString()+"\n and values "+regressionValueMatrix.toString());
					
					var pseudoInversePointMatrix = regressionPointMatrix.getPseudoInverse();//Nx(d+1) gets pseudo-inverse (d+1)xN
					
					//console.log("pseudo inverse of point matrix: "+pseudoInversePointMatrix.toString());
					
					weightMatrix = pseudoInversePointMatrix.getProduct(regressionValueMatrix);//(d+1)xN times Nx1 comes out to a (d+1)x1 column array.
                    
				}
                
                //console.log("computed weights: "+weightMatrix.toString());
                
                this.toString = function() {
                    return "LinearGradient: { weightMatrix"+weightMatrix.toString()+" }";
                };
                
                //point: a point matrix of the same dimensions as the ones we passed in on init, 1x3 if none
                this.evaluateAt = function(point) {
                    
                    var sumMatrix = point.getProduct(weightMatrix);// 1x(d+1) times (d+1)x1 = 1x1
                    
                    return signFunction( sumMatrix.getElement(0, 0) );
                };
                
                //points: an array of point matrices
                this.evaluateAtAll = function(pointMatrix) {
                    return ( pointMatrix.getProduct(weightMatrix) ).getElementWiseTransform(signFunction);//Nx(d+1) times (d+1)x1 gives Nx1 column array
                };
                
				//Perform a step of the perceptron learning algorithm: weightMatrix <- weightMatrix + targetF(X)*X
				this.updateWeights = function(pointMatrix, valueMatrix) {
				    var pointColumnMatrix = pointMatrix.getTranspose();//1x(d+1) to (d+1)x1
					var signedPointColumnMatrix = pointColumnMatrix.getProduct(valueMatrix);//(d+1)x1 times 1x1 gives (d+1)x1
					weightMatrix = weightMatrix.getSum( signedPointColumnMatrix );//(d+1)x1 plus (d+1)x1
					//console.log("adjusted weights to "+weightMatrix.toString());
				};
                
                this.getWeights = function() {
                   return weightMatrix;
                };
				
				//If the weights are for a conic section, we should have 6: w0*1+w1*x1+w2*x2+w3*x1*x2+w4*x1*x1+w5*x2*x2
				this.isConic = function() {
				    return weightMatrix.getNumRows() == 6;
				};
                
            }//end of LGradient
            
			//helper function for flipSignsRandomly
            //returns numValues different integers on [minValue, maxValuePlusOne) in ascending order
            function selectRandomIntValues(minValue, maxValuePlusOne, numValues) {
                var values = new Array();
                
                var newValue;
                var duplicateFound;
                var placeFound;
                var index;
                //Generate random numbers until we have enough.
                while(values.length < numValues) {
                    newValue = Math.floor( minValue + (maxValuePlusOne - minValue)*Math.random() );
                    duplicateFound = false;
                    placeFound = false;
                    //As we build the list, we keep it in ascending order.
                    for(index = 0; index < values.length; index++) {
                        if( newValue == values[index] ) {
                            duplicateFound = true;//This is a duplicate value, so do not store it.
                            break;
                        }
                        else if( newValue < values[index] ) {
                            //The values are already in ascending order, so we must be at the first value greater than the new value.
                            values.splice(index, 0, newValue);//Splice this value in at the current index, shifting up the indeces of all greater values.
                            placeFound = true;
                            break;
                        }
                    }
                    if( (!duplicateFound) && (!placeFound) ) {
                        values.push(newValue);//new value is greater than all values so far
                    }
                }
                
                return values;
            }
            
			//helper function for generateConicTargetFunctionAndNoisyData
            //matrix: any matrix
            //fractionToFlip: the fraction of the elements of which the function should flip the signs
            //returns a copy of the matrix with (numRows*numColumns)*fractionToFlip randomly selected elements having opposite signs 
            function flipSignsRandomly(matrix, fractionToFlip) {
                if(fractionToFlip > 1) {
                    console.log("flipSignsRandomly: received fractionToFlip value "+fractionToFlip+" > 1");
                }
                var numRows = matrix.getNumRows();
                var numColumns = matrix.getNumColumns();
                var numElements = numRows * numColumns;
                var numElementsToSelect = Math.round( Math.min(fractionToFlip, 1) * numElements );
                var selectedElements = selectRandomIntValues(0, numElements, numElementsToSelect);//These should be in ascending order.
                var selectedElementsIndex = 0;//start looking for the first selected value
                var rowIndex;
                var columnIndex;
                var elementIndex;
                var sourceRow;
                var newRow;
                var newElement;
                var noisyMatrix = new Matrix();
                
                for(rowIndex = 0; rowIndex < numRows; rowIndex++) {
                    sourceRow = matrix.getRow(rowIndex);
                    newRow = new Array();
                    for(columnIndex = 0; columnIndex < numColumns; columnIndex++) {
                        elementIndex = numColumns*rowIndex + numColumns;
                        if( elementIndex == selectedElements[selectedElementsIndex] ) {
                            newElement = -1*sourceRow[columnIndex];//selected, so flip the sign
                            selectedElementsIndex++;//We have found this selected element index, so move on to the next one.
                        }
                        else {
                            newElement = sourceRow[columnIndex];//not selected, so leave as is
                        }
                        newRow.push(newElement);
                    }
                    noisyMatrix.pushRow(newRow);
                }
                
                return noisyMatrix;
            }
			
			function generateRandomLinearTargetFunctionAndData() {
                targetGradient = new LinearGradient();
                targetInValues = targetGradient.evaluateAtAll(inPoints);
                //console.log( "generated in-sample target values "+targetInValues.toString() );
                targetOutValues = targetGradient.evaluateAtAll(outPoints);
                //console.log( "generated out-of-sample target values "+targetOutValues.toString() );
			}
			
			function generateConicTargetFunctionAndNoisyData() {
				targetGradient = new LinearGradient(targetNonLinearWeightArray);
                //Flip the signs on 1/10 of the points.
                targetInValues = flipSignsRandomly( targetGradient.evaluateAtAll(augmentedInPoints), 0.1 );
                //console.log( "generated in-sample target values "+targetInValues.toString() );
                targetOutValues = flipSignsRandomly( targetGradient.evaluateAtAll(augmentedOutPoints), 0.1 );
                //console.log( "generated out-of-sample target values "+targetOutValues.toString() );
			}
			
			function generateHypothesisDataAndDiffHalfData() {
			    
			    var whichInPoints;
				var whichOutPoints;
			    if( hypothesisGradient.isConic() ) {
				    whichInPoints = augmentedInPoints;
					whichOutPoints = augmentedOutPoints;
				}
				else {
				    whichInPoints = inPoints;
					whichOutPoints = outPoints;
				}
				
                hypothesisInValues = hypothesisGradient.evaluateAtAll(whichInPoints);
                //console.log( "generated in-sample hypothesis values "+hypothesisInValues.toString() );
                hypothesisOutValues = hypothesisGradient.evaluateAtAll(whichOutPoints);
                //console.log( "generated out-of-sample hypothesis values "+hypothesisOutValues.toString() );
				
				var diffOut = hypothesisOutValues.getSum(targetOutValues.getScaled(-1));
				diffHalfOut = diffOut.getScaled(0.5);
				
				var diffIn = hypothesisInValues.getSum(targetInValues.getScaled(-1));
				diffHalfIn = diffIn.getScaled(0.5);
				//console.log("errors: "+diffHalfIn.toString());
				
			}
			
			//**** These functions plot the in-sample points, out-of-sample points, target function, and hypothesis function. Call them after generating all the data.****
            
            function pointX1X2ToCanvasXY(x1, x2) {
                var diff = pointMaxCoord - pointMinCoord;//constant
                var xVal = Math.round(  ( lCanvas.width*(x1 - pointMinCoord) )/diff  );
                var yVal = Math.round( lCanvas.height - ( lCanvas.height*(x2 - pointMinCoord) )/diff  );//matrix coordinates: x2 increases bottom to top, canvas: y increases top to bottom
                return { x: xVal , y: yVal };
            }
            
			//in sample and negative -> red
			//out of sample and positive -> cyan
            function valueToColor(value, inSample) {
			    var colorAmp = Math.abs( Math.round(256*value) );
				var alpha = inSample ? 1:0.5;
                if(value > 0) {
                    return "rgba(0, 0, "+colorAmp+", "+alpha+")";
                }
                else {
                    return "rgba("+colorAmp+", 0, 0, "+alpha+")";
                }
            }
            
			//points: Nx(d+1) Matrix, the points to plot
			//values: Nx1 Matrix, values from -1 to 1 telling us how to color the points, -1->red, 0->black, 1->blue
			//inSample: bool, whether these are in-sample or out-of-sample. If they are out-of-sample, we plot them semi-transparent
			//selectedPoint: 1x(d+1) Matrix, optional and nullable argument representing a point we should circle in plaSelectedPointColor
            function plotPointMatrix(points, values, inSample, selectedPoint) {
                var rowIndex;
                var pointRow;
                var value;
                var cPoint;
				
                for(rowIndex = 0; rowIndex < points.getNumRows(); rowIndex++) {
                    pointRow = points.getRow(rowIndex);
                    value = values.getElement(rowIndex, 0);
                    cPoint = pointX1X2ToCanvasXY( pointRow[1], pointRow[2] );
                    lContext.beginPath();
                    lContext.arc(cPoint.x, cPoint.y, pointPlotRadius, 0, 2*Math.PI);
                    lContext.closePath();
					lContext.fillStyle = valueToColor(value, inSample);
                    lContext.fill();
					
					
					if(inSample === "selected") {
					}
					
                }
				
				//Circle the selected point.
				if( ( typeof selectedPoint !== "undefined" ) && (selectedPoint != null) ) {
                    pointRow = selectedPoint.getRow(0);
                    cPoint = pointX1X2ToCanvasXY( pointRow[1], pointRow[2] );
					lContext.beginPath();
					lContext.arc(cPoint.x, cPoint.y, 1.5*pointPlotRadius, 0, 2*Math.PI);
					lContext.closePath();
					lContext.strokeStyle = plaSelectedPointColor;
					lContext.stroke();
				}
				
            }
			
			//Find the x2 for which w0+w1*x1+w2*x2 = 0 for the given W and x1.
			function find0LineX2For(linearWeights, x1) {
			    return -1*( (linearWeights.getElement(0, 1))*x1 + (linearWeights.getElement(0, 0)) )/(linearWeights.getElement(0, 2));
			}
			
			//Given a weight matrix [[w0], [w1], [w2]], plot the line w0+w1*x1+w2*x2 = 0.
			function plotSignDividingLine(linearWeights, lineColor) {
				var leftX2 = find0LineX2For(linearWeights, pointMinCoord);
				var rightX2 = find0LineX2For(linearWeights, pointMaxCoord);
				var leftCanvasPoint = pointX1X2ToCanvasXY(pointMinCoord, leftX2);
				var rightCanvasPoint = pointX1X2ToCanvasXY(pointMaxCoord, rightX2);
				lContext.beginPath();
				lContext.moveTo(leftCanvasPoint.x, leftCanvasPoint.y);
				lContext.lineTo(rightCanvasPoint.x, rightCanvasPoint.y);
				lContext.strokeStyle = lineColor;
				lContext.stroke();
			}
			
			//Given a weight matrix [[w0], [w1], [w2], [w3], [w4], [w5]], plots the conic section w0+w1*x1+w2*x2+w3*x1*x2+w4*x1*x1+w5*x2*x2 = 0.
            function plotSignDividingConicSection(conicWeights, strokeColor) {
			    
				var w0  = conicWeights.getElement(0, 0);//the x0, or constant, term weight
				var w1  = conicWeights.getElement(0, 1);//the x1, or x, term weight
				var w2  = conicWeights.getElement(0, 2);//the x2, or x, term weight
				var w3 = conicWeights.getElement(0, 3);//the x1*x2, or xy, term weight
				var w4 = conicWeights.getElement(0, 4);//the x1*x1, or x^2, term weight
				var w5 = conicWeights.getElement(0, 5);//the x2*x2, or y^2, term wieght
				
				//General formula for x2 as a function of x1:
				//Start with a general conic section: w0+w1*x1+w2*x2+w3*x1*x2+w4*x1*x1+w5*x2*x2 = 0.
				//Rewrite in polar coordinates: w0+w1*r*cos(a)+w2*r*sin(a)+w3*r*sin(a)*r*cos(a)+w4*r*cos(a)*r*cos(a)+w5*r*sin(a)*r*sin(a) = 0.
				//Group terms by power of r: (w3*sin(a)*cos(a)+w4*cos(a)*cos(a)+w5*sin(a)*sin(a))*r*r + (w1*cos(a)+w2*sin(a))*r + w0 = 0.
				//Solve for r: r = (  -(w1*cos(a)+w2*sin(a))  +or-  sqrt( (w1*cos(a)+w2*sin(a))^2 - 4*(w3*sin(a)*cos(a)+w4*cos(a)*cos(a)+w5*sin(a)*sin(a))*w0 )  )/( 2*((w3*sin(a)*cos(a)+w4*cos(a)*cos(a)+w5*sin(a)*sin(a))) ).
				//Simplify: r = (  -(w1*cos(a)+w2*sin(a))  +or-  sqrt( ((w2^2-w1^2)-4*w0(w5-w4))*sin(a)^2 + (w1^2-4*w0*w4) + (2*w1*w2-4*w0*w3)*sin(a)*cos(a) )  )/(  2*( (w5-w4)*sin(a)^2 + w4 + w3*sin(a)*cos(a) )  ).
				//Name some additional variables for the more complicated constants: 
				//in the discriminant: 
				var coeffSSDisc = (w2*w2-w1*w1)-4*w0*(w5-w4);
				var coeffSCDisc = 2*w1*w2-4*w0*w3;
				var constDisc = w1*w1-4*w0*w4;
				//in the denominator (distributing the 2):
				var coeffSSDenom = 2*(w5-w4);
				var coeffSCDenom = 2*w3;
				var constDenom = 2*w4;
				
				//Scale so that the change in x2 for each step is around 1 pixel:
				var resolution = (pointMaxCoord - pointMinCoord)/(Math.max(lCanvas.width, lCanvas.height));
				
				var pointsPlus = new Array();
				var pointsMinus = new Array();
				var points;
				
				var angle = 0;
				var angleIncrement = Math.PI/1024;
				var sin_a;
				var cos_a;
				var sin_a_sq;
				var sinxcos_a;
				var discriminant;
				var denominator;
				var sqrt_disc;
				var radiusMinus;
				var radiusPlus;
				var pointMinus;
				var pointPlus;
				var afterGap = true;
				while(angle < 2*Math.PI) {
				    
					sin_a = Math.sin(angle);
					cos_a = Math.cos(angle);
					sin_a_sq = sin_a*sin_a;
					sinxcos_a = sin_a*cos_a;
					discriminant = coeffSSDisc*sin_a_sq + coeffSCDisc*sinxcos_a + constDisc;
					denominator = coeffSSDenom*sin_a_sq + coeffSCDenom*sinxcos_a + constDenom;
					//console.log("angle="+angle+", discriminant="+discriminant+", denominator="+denominator);
					//Only try to calculate the radius if it is defined and real.
					if( (discriminant >= 0)&&(denominator != 0) ) {
					    sqrt_disc = Math.sqrt(discriminant);
					    radiusMinus = (-1*(w1*cos_a + w2*sin_a) - sqrt_disc)/denominator;
					    radiusPlus = (-1*(w1*cos_a + w2*sin_a) + sqrt_disc)/denominator;
						pointMinus = { x1:radiusMinus*cos_a , x2:radiusMinus*sin_a, afterGap:afterGap };
						//console.log("adding minus point:");
						//console.log(pointMinus);
						pointPlus = { x1:radiusPlus*cos_a , x2:radiusPlus*sin_a, afterGap:afterGap };
						//console.log("adding plus point:");
						//console.log(pointMinus);
						pointsMinus.push( pointMinus );
						pointsPlus.push( pointPlus );
						afterGap = false;
					}
					else {
					    afterGap = true;
					}
					
				    angle += angleIncrement;
				}
				
				points = pointsMinus.concat(pointsPlus);//Combine them in case one missed some points.
				var pointIndex;
				var canvasPoint;
				lContext.beginPath();
				for(pointIndex = 0; pointIndex < points.length; pointIndex++) {
				    canvasPoint = pointX1X2ToCanvasXY(points[pointIndex].x1, points[pointIndex].x2);
					if(points[pointIndex].afterGap) {
					    //console.log("moving to ("+canvasPoint.x+","+canvasPoint.y+")");
					    lContext.moveTo(canvasPoint.x, canvasPoint.y);
					}
					else {
					    //console.log("lining to ("+canvasPoint.x+","+canvasPoint.y+")");
					    //Consider ways to make this look more curved.
					    lContext.lineTo(canvasPoint.x, canvasPoint.y);
					}
				}
				lContext.strokeStyle = strokeColor;
				lContext.stroke();
				
            }//end of plotSignDividingConicSection
			
			function plotAll() {
			    
                lContext.clearRect(0, 0, lCanvas.width, lCanvas.height);
				
                plotPointMatrix(inPoints, diffHalfIn, true, plaSelectedPoint);//plaSelectedPoint may be null
                plotPointMatrix(outPoints, diffHalfOut, false);//selectedPoint is optional
				
				if( targetGradient.isConic() ) {
				    plotSignDividingConicSection(targetGradient.getWeights(), targetLineColor);
				}
				else {
				    plotSignDividingLine(targetGradient.getWeights(), targetLineColor);
				}
				
				if( hypothesisGradient.isConic() ) {
				    plotSignDividingConicSection(hypothesisGradient.getWeights(), hypothesisLineColor);
				}
				else {
				    plotSignDividingLine(hypothesisGradient.getWeights(), hypothesisLineColor);
				}
				
			}
			
			//**** These functions store the result of the current experiment. Call them after generating all the data. ****
            
			//We do not use this function in the current version, but we may have use for it later.
            //takes in two Nx1 matrices and returns ( (a0-b0)^2 + (a1-b1)^2 + … + (aN-bN)^2 )/N
            function computeSquaredError(targetValues, hypothesisValues) {
                
                if(targetValues.getNumRows() != hypothesisValues.getNumRows()) {
                    console.log("Warning: computing error with "+targetValues.numRows()+" target values and "+hypothesisValues.getNumRows()+" hypothesis values");
                }
                var numValues = Math.min(targetValues.getNumRows(), hypothesisValues.getNumRows());
                //console.log("target values: "+targetValues.toString());
                //console.log("hypothesis values: "+hypothesisValues.toString());
                //console.log("-(target values): "+ ( targetValues.getScaled(-1) ).toString() );
                var diff = hypothesisValues.getSum( targetValues.getScaled(-1) );//Nx1
                //console.log("differences: "+diff.toString());
                var diffTranspose = diff.getTranspose();//1xN
                //console.log("differences tanspose: "+diffTranspose.toString());
                var errorMatrix = diffTranspose.getProduct(diff);//1xN times Nx1 gives 1x1
                //console.log("error matrix: "+errorMatrix.toString());
                
                return errorMatrix.getElement(0, 0)/numValues;
            }
            
            //takes in diffHalfIn or diffHalfOut and returns (diffHalf00^2 + diffHalf10^2 + ... + diffHalfN0^2)/N, which is the fraction of points misclassified
            function computeClassificationError(diffHalf) {//diff
                var diffHalfTranspose = diffHalf.getTranspose();//1xN
                //console.log("differences tanspose: "+diffTranspose.toString());
                var errorMatrix = diffHalfTranspose.getProduct(diffHalf);//1xN times Nx1 gives 1x1, and (-1)^2 = (+1)^2 = 1.
                //console.log("error matrix: "+errorMatrix.toString());
                return ( errorMatrix.getElement(0, 0) )/( diffHalf.getNumRows() );
            }
            
            function ExperimentResult(inError, outError, stepsToConverge, weights) {
                this.inError = inError;
                this.outError = outError;
                this.stepsToConverge = stepsToConverge;
                this.weights = weights;
            }
			
			function storeExperimentResult() {
				results.push( new ExperimentResult(  computeClassificationError(diffHalfIn), computeClassificationError(diffHalfOut), plaStepCount, hypothesisGradient.getWeights() )  );
			}
			
			//**** These functions perform a single iteration of one of the experiments. The ones that do not involve the PLA complete in one iteration. ****
			
            function doLinearRegression() {
				
				generatePoints(false);//false->no augmented columns
				
                generateRandomLinearTargetFunctionAndData();
				
                hypothesisGradient = new LinearGradient(inPoints, targetInValues);
                
                generateHypothesisDataAndDiffHalfData();
				
				plotAll();
				
				storeExperimentResult();
            }
			
			//helper function for doPLA and doLinearRegressionAndPLA to avoid duplication of code
			function initPLA(initWithLinearRegression) {
				
				generatePoints(false);//false->no augmented columns
				
                generateRandomLinearTargetFunctionAndData();
				
				if(initWithLinearRegression) {
                    hypothesisGradient = new LinearGradient(inPoints, targetInValues);
				}
				else {
					hypothesisGradient = new LinearGradient(zeroed2DWeightMatrix);//uses zeroed weights by default
				}
				
				runningPLA = true;
				plaStepCount = 0;
				plaSelectedPoint = null;
				console.log( "starting PLA with perceptron "+hypothesisGradient.toString() );
			}
			
			//helper function for doPLA and doLinearRegressionAndPLA to avoid duplication of code
			function doPLAUpdate() {
				//The current hypothesis misclassifies one or more points, so adjust it.
				hypothesisGradient.updateWeights(plaSelectedPoint, plaSelectedTargetValue);
				//console.log( "updated perceptron "+perceptron.toString() );
				plaStepCount++;//Count every update of the weights as a step in the PLA.
			}
			
			//helper method for doPLAEvaluationAndPointSelection
			//sets plaSelectedPoint and plaSelectedTargetValue
			//This function needs diffHalfIn, so call it after generateHypothesisDataAndDiffHalfData.
			//It also assumes that each entry in diffHalfIn is -1, 0, or 1.
			function selectRandomMisclassifiedPoint() {
			    
				plaSelectedPoint = null;
				plaSelectedTargetValue = null;
				
				var numErrorPoints = ( ( diffHalfIn.getTranspose() ).getProduct(diffHalfIn) ).getElement(0, 0);//1xN times Nx1 gives 1x1.
				
				//console.log("misclassified points: "+numErrorPoints);
				if(numErrorPoints >= 1) {
					var numErrorPointsToSkip = Math.floor( numErrorPoints*Math.random() );//random number from 0(pick the first one) to numErrorPoints-1 (pick the last)
					//console.log("skipping first "+numErrorPointsToSkip+" misclassified points");
					var index = 0;
					while(plaSelectedPoint == null) {
						if(diffHalfIn.getElement(index, 0) != 0) {//If this is a misclassified point,
							if(numErrorPointsToSkip > 0) {
								//console.log("skipping misclassified point at index "+index);
								numErrorPointsToSkip--;//Skip this misclassified point.
							}
							else {
								//Choose this misclassified point.
				                plaSelectedPoint = inPoints.getBlock( index, 0, 1, inPoints.getNumColumns() );//A single point is all the columns in this row.
								plaSelectedTargetValue = targetInValues.getBlock( index, 0, 1, targetInValues.getNumColumns() );//Should only be one column in the row.
					            //console.log( "selected misclassified point at index "+index+", point: "+plaSelectedPoint.toString()+", value: "+plaSelectedTargetValue.toString() );
							}
						}
						index++;//We should find the chosen point before we run through all the points.
					}//end of while no index of a misclassified point chosen
				}//end of if 1 or more misclassified points
				else {
				    //The current hypothesis correctly classifies all points, so conclude the experiment.
					console.log( "Perceptron converged to "+hypothesisGradient.toString()+" in "+plaStepCount+" steps." );
					runningPLA = false;
				}
				
				
			}
			
			//helper function for doPLA and doLinearRegressionAndPLA to avoid duplication of code
			function doPLAEvaluationAndPointSelection() {
                
                generateHypothesisDataAndDiffHalfData();
				
				selectRandomMisclassifiedPoint();//This function needs diffHalfIn.
				
				plotAll();
				
				if(!runningPLA) {
					storeExperimentResult();
				}
				
			}//doPLAEvaluationAndPointSelection
			
            function doPLA() {
                
				if(runningPLA) {//We generated a hypothesis and tested it in the previous step.
					doPLAUpdate();
				}
				else {//This is the first step, so generate an initial hypothesis.
					initPLA(false);//false->Start with zeroed weights.
				}
				
				//Test the current hypothesis.
				doPLAEvaluationAndPointSelection();
				
            }//end of doLinearRegressionAndPLA
            
            function doLinearRegressionAndPLA() {
                
				if(runningPLA) {//We generated a hypothesis and tested it in the previous step.
				    doPLAUpdate();
				}
				else {//This is the first step, so use linear regression to generate an initial hypothesis.
					initPLA(true);//true->Use a linear regression to get the initial weights.
				}
				
				//Test the current hypothesis.
				doPLAEvaluationAndPointSelection();
				
            }//end of doLinearRegressionAndPLA
            
            function doLinearRegressionOnNonLinearFunction() {
                
                generatePoints(true);//true->create augmented points
				
                generateConicTargetFunctionAndNoisyData();
				
                hypothesisGradient = new LinearGradient(inPoints, targetInValues);
                
                generateHypothesisDataAndDiffHalfData();
				
				plotAll();
				
				storeExperimentResult();
            }
            
            function doNonLinearRegression() {
                
                generatePoints(true);//true->create augmented points
				
                generateConicTargetFunctionAndNoisyData();
				
                hypothesisGradient = new LinearGradient(augmentedInPoints, targetInValues);
                
                generateHypothesisDataAndDiffHalfData();
				
				plotAll();
				
				storeExperimentResult();
            }
            
			//**** These functions control the process of stepping through the correct number of repetitions of the selected experiment. *****
			
            function pause() {
                document.getElementById("pauseButton").disabled = true;
                document.getElementById("resumeButton").disabled = false;
                clearInterval(stepInterval);//stop iterating
            }
			
            function appendNotice(noticeText) {
                var para=document.createElement("p");
                var node=document.createTextNode(noticeText);
                var notices = document.getElementById("notices");
                
                para.appendChild(node);
                notices.appendChild(para);
            }
            
            function stop() {
                pause();
                document.getElementById("resumeButton").disabled = true;//We have finished, so we cannot resume.
				if(results.length > 0) {
                    var index;
                    var sumInError = 0;
                    var sumOutError = 0;
                    var sumStepsToConverge = 0;
                    var sumWeights = new Matrix();
                    sumWeights.fillWithValue(  ( (results[0]).weights ).getNumRows(),  ( (results[0]).weights ).getNumColumns(),  0  );//start with an array of 0s in the same dimensions as the other weights
				    
                    for(index=0; index<results.length; index++) {
                        sumInError += results[index].inError;
                        sumOutError += results[index].outError;
                        sumStepsToConverge += results[index].stepsToConverge;
                        sumWeights = sumWeights.getSum( results[index].weights );
                    }
				
                    var averageInError = sumInError/results.length;
                    var averageOutError = sumOutError/results.length;
                    var averageStepsToConverge = sumStepsToConverge/results.length;
                    var averageWeights = sumWeights.getScaled( 1.0/results.length );
                    appendNotice( ""+results.length+" Experiments Complete: average in-sample error = "+averageInError+", average out-of-sample error = "+averageOutError+", average steps to converge = "+averageStepsToConverge+", average weights: "+averageWeights.toString() );
				}
				else {
				    appendNotice("No Experiments Complete: no results to report");
				}
            }
            
            function step() {
				//Do another experiment of the specified type or an iteration of the PLA.
				experimentFunction();
				experimentCountSpan.innerHTML = results.length;
				if(results.length >= numExperiments) {
					stop();
				}
            }//end of step
            
            function resume() {
                document.getElementById("pauseButton").disabled = false;
                document.getElementById("resumeButton").disabled = true;
                stepInterval = setInterval(step, millisecondsPerStep);//start iterating
            }
            
            function start() {
			    runningPLA = false;//This tells it to start a new PLA instead of continuing one that may already be in progress.
				plaStepCount = 0;//No PLA steps completed.
				plaSelectedPoint = null;//PLA has not selected a misclassified point to use when adjusting weights.
                results = new Array();//No ExperimentResults stored yet.
                numExperiments = document.getElementById("numExperimentsInput").value;
                millisecondsPerStep = document.getElementById("millisecondsPerStepInput").value;
				var experimentType = document.getElementById("experimentSelect").value;
				switch(experimentType) {
					case "linearRegression":
					experimentFunction = doLinearRegression;
					break;
					case "pla":
					experimentFunction = doPLA;
					break;
					case "linearRegressionAndPla":
					experimentFunction = doLinearRegressionAndPLA;
					break;
					case "linearRegressionOnNonLinearData":
					experimentFunction = doLinearRegressionOnNonLinearFunction;
					break;
					case "nonLinearRegression":
					experimentFunction = doNonLinearRegression;
					break;
					default:
					experimentFunction = null;
					console.log("bad option \""+experimentType+"\" selected for experimentType");
				}
                resume();
            }
            
            function init() {
                
                lCanvas=document.getElementById("linearRegressionCanvas");
                lContext=lCanvas.getContext("2d");
                document.getElementById("startButton").onclick = start;
                document.getElementById("pauseButton").onclick = pause;
                document.getElementById("resumeButton").onclick = resume;
                experimentCountSpan = document.getElementById("experimentCount");
                
            }
            
            </script>
    </head>
    <body onload="init();">
        
        <form>
		    <label for="experimentSelect">Experiment:</label>
			<select id="experimentSelect">
			<option value="linearRegression">Linear Regression on Linearly Separable Data</option>
			<option value="pla">PLA on Linearly Separable Data</option>
			<option value="linearRegressionAndPla">Linear Regression and PLA on Linearly Separable Data</option>
			<option value="linearRegressionOnNonLinearData">Linear Regression on Non-Linearly Separable Data</option>
			<option value="nonLinearRegression">Augmented Linear Regression on Non-Linearly Separable Data</option>
			</select>
            <label for="numExperimentsInput">Number of Experiments:</label><input id="numExperimentsInput" type="number" value="1"></input>
            <label for="numInPointsInput">Number of In-Sample Points:</label><input id="numInPointsInput" type="number" value="1000"></input>
            <label for="nuOutPointsInput">Number of Out-of-Sample Points:</label><input id="numOutPointsInput" type="number" value="1000"></input>
            <label for="millisecondsPerStepInput">Milliseconds per Step:</label><input id="millisecondsPerStepInput" type="number" value="1000"></input>
            <input id="startButton" type="button" value="Start" />
            <input id="pauseButton" type="button" value="Pause" disabled/>
            <input id="resumeButton" type="button" value="Resume" disabled/>
        </form>
        <canvas id="linearRegressionCanvas" width="300" height="300" style="border:1px solid #c3c3c3;">
            Your browser does not support the HTML5 canvas tag.
        </canvas>
        <div>Completed Experiments:<span id="experimentCount">0</span></div>
        <div id="notices">Notices:</div>
		<div>
		<h1>Key:</h1> 
		<p>target function: cyan line/curve</p>
		<p>hypothesis function: yellow line/curve</p>
		<p>correctly classified in-sample points: black dots</p>
		<p>correctly classified out-of-sample points: gray dots</p>
		<p>in-sample points incorrectly classified as negative: red</p>
		<p>out-of-sample points incorrectly classified as negative: pink</p>
		<p>in-sample points incorrectly classified as positive: blue</p>
		<p>out-of-sample points incorrectly classified as positive: light blue</p>
		<p>incorrectly classified in-sample point selected for learning by PLA: circled in magenta</p>
		</div>
    </body>
</html>